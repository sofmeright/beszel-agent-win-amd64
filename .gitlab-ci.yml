stages:
  - build
  - release

variables:
  BINARY_NAME: "beszel-agent_windows_amd64.exe"
  UPSTREAM_REPO_URL: "https://github.com/henrygd/beszel.git"
  LHM_REPO_URL: "https://github.com/LibreHardwareMonitor/LibreHardwareMonitor.git"
  GITLAB_DOMAIN: "https://gitlab.prplanit.com"
  OUTPUT_DIR: "beszel-agent_windows_amd64-$CI_COMMIT_TAG"
  ZIP_NAME: "$OUTPUT_DIR.zip"

build-release:
  before_script: |
    echo "---------------------------------------------------------------------------"
    echo "AntParade GitOps üêú - Preparing $CI_JOB_IMAGE image for build..."
    echo "---------------------------------------------------------------------------"
    echo "Installing dependencies... (git, zip, wget, curl)"
    apt-get update && apt-get install -y git zip wget curl
    
    # Install .NET 8 SDK (which can build .NET Framework 4.8)
    wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
    chmod +x dotnet-install.sh
    bash ./dotnet-install.sh --channel 8.0 --install-dir /usr/share/dotnet
    ln -s /usr/share/dotnet/dotnet /usr/local/bin/dotnet
    export PATH="/usr/share/dotnet:$PATH"
    
    # Verify installations
    dotnet --version
    go version
  environment: production
  image: golang:1.24.5-bullseye
  rules:
    - if: $CI_COMMIT_TAG
  stage: build
  script: |
    echo "---------------------------------------------------------------------------"
    echo "AntParade GitOps üêú - Building $OUTPUT_DIR with LibreHardwareMonitor..."
    echo "---------------------------------------------------------------------------"
    
    # Clone LibreHardwareMonitor first
    echo "Cloning LibreHardwareMonitor..."
    git clone --depth 1 $LHM_REPO_URL lhm-source
    
    # Build LibreHardwareMonitor for .NET Framework 4.8
    cd lhm-source
    echo "Building LibreHardwareMonitor for .NET Framework 4.8..."
    
    # Try to build - LibreHardwareMonitor might use different target frameworks
    # We'll try multiple approaches to get .NET 4.8 compatible binaries
    if [ -f "LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj" ]; then
        echo "Found LibreHardwareMonitorLib project, building..."
        dotnet build LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj -c Release -f net48 || \
        dotnet build LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj -c Release -f net6.0 || \
        dotnet build LibreHardwareMonitorLib/LibreHardwareMonitorLib.csproj -c Release
    elif [ -f "LibreHardwareMonitor.sln" ]; then
        echo "Found solution file, building entire solution..."
        dotnet build LibreHardwareMonitor.sln -c Release || echo "Solution build failed, trying individual projects..."
    fi
    
    # Find the built binaries
    echo "Looking for built LibreHardwareMonitor binaries..."
    find . -name "*.dll" -path "*/bin/Release/*" | head -10
    find . -name "LibreHardwareMonitorLib.dll" -path "*/bin/Release/*" | head -5
    
    cd ..
    
    # Clone Beszel
    echo "Cloning the $CI_COMMIT_TAG branch of $UPSTREAM_REPO_URL..."
    git clone --depth 1 --branch $CI_COMMIT_TAG $UPSTREAM_REPO_URL
    
    # Create the LHM directory structure that Beszel expects
    echo "Setting up LibreHardwareMonitor binaries for Beszel embed..."
    mkdir -p beszel/beszel/cmd/agent/lhm/bin/Release/net48
    
    # Copy LHM binaries to the expected location
    # Look for the most common locations where .NET builds output
    LHM_BINARY_PATHS=(
        "lhm-source/LibreHardwareMonitorLib/bin/Release/net48"
        "lhm-source/LibreHardwareMonitorLib/bin/Release/net6.0"
        "lhm-source/LibreHardwareMonitorLib/bin/Release"
        "lhm-source/bin/Release/net48"
        "lhm-source/bin/Release"
    )
    
    LHM_FOUND=false
    for path in "${LHM_BINARY_PATHS[@]}"; do
        if [ -d "$path" ] && [ "$(ls -A $path 2>/dev/null)" ]; then
            echo "Found LHM binaries in: $path"
            cp -r $path/* beszel/beszel/cmd/agent/lhm/bin/Release/net48/ 2>/dev/null || true
            if [ "$(ls -A beszel/beszel/cmd/agent/lhm/bin/Release/net48/ 2>/dev/null)" ]; then
                LHM_FOUND=true
                break
            fi
        fi
    done
    
    # If we didn't find binaries in standard locations, do a broader search
    if [ "$LHM_FOUND" = false ]; then
        echo "Searching for any LibreHardwareMonitor DLLs..."
        find lhm-source -name "*.dll" -type f -exec cp {} beszel/beszel/cmd/agent/lhm/bin/Release/net48/ \; 2>/dev/null || true
        
        # Check if we got any files
        if [ "$(ls -A beszel/beszel/cmd/agent/lhm/bin/Release/net48/ 2>/dev/null)" ]; then
            LHM_FOUND=true
        fi
    fi
    
    if [ "$LHM_FOUND" = true ]; then
        echo "‚úÖ LibreHardwareMonitor binaries prepared:"
        ls -la beszel/beszel/cmd/agent/lhm/bin/Release/net48/
    else
        echo "‚ö†Ô∏è  Warning: Could not find LibreHardwareMonitor binaries. Building without LHM support."
        # Clean up empty directory to avoid embed errors
        rm -rf beszel/beszel/cmd/agent/lhm
    fi
    
    # Build Beszel agent
    cd beszel/beszel/cmd/agent
    echo "Building $BINARY_NAME from the source for $OUTPUT_DIR..."
    
    # Try building with LHM support first, fall back without it
    if [ "$LHM_FOUND" = true ]; then
        echo "Building with LibreHardwareMonitor support..."
        GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build -ldflags "-w -s" -o $BINARY_NAME
        BUILD_STATUS=$?
    else
        BUILD_STATUS=1  # Force fallback
    fi
    
    # If LHM build failed, try without LHM
    if [ $BUILD_STATUS -ne 0 ]; then
        echo "Falling back to build without LibreHardwareMonitor..."
        rm -rf lhm  # Remove LHM directory to avoid embed issues
        GOOS=windows GOARCH=amd64 CGO_ENABLED=0 go build -ldflags "-w -s" -o $BINARY_NAME
    fi

    echo "Packaging release into $ZIP_NAME..."
    mkdir -p "$CI_PROJECT_DIR/$OUTPUT_DIR"
    mv $BINARY_NAME "$CI_PROJECT_DIR/$OUTPUT_DIR/"
    cd "$CI_PROJECT_DIR"
    zip -r "$ZIP_NAME" "$OUTPUT_DIR"

    echo "$ZIP_NAME has been packaged, here are its details:"
    ls -lh "$ZIP_NAME"
    
    echo "AntParade GitOps üêú - build-release job complete."

  artifacts:
    paths:
      - "$ZIP_NAME"
    expire_in: 1 week

create-release:
  before_script: |
    echo "---------------------------------------------------------------------------"
    echo "AntParade GitOps üêú - Preparing $CI_JOB_IMAGE image for release upload tasks"
    echo "---------------------------------------------------------------------------"
    echo "Installing dependencies... (bash curl jq)"
    apk add --no-cache bash curl jq
  dependencies:
    - build-release
  stage: release
  image: alpine:latest
  rules:
    - if: $CI_COMMIT_TAG
  script: |
    echo "---------------------------------------------------------------------------"
    echo "AntParade GitOps üêú - Begin tasks for upload of $BINARY_NAME $CI_COMMIT_TAG"
    echo "---------------------------------------------------------------------------"
    echo "Creating release $CI_COMMIT_TAG..."
    curl --header "PRIVATE-TOKEN: $GITLAB_TOKEN" --request POST \
      --form "name=Release $CI_COMMIT_TAG" \
      --form "tag_name=$CI_COMMIT_TAG" \
      --form "description=AntParade GitOps üêú packaged $CI_COMMIT_TAG release of $CI_PROJECT_NAME with LibreHardwareMonitor support." \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases" || echo "Release might already exist"

    echo "Uploading $ZIP_NAME to the $CI_PROJECT_NAME gitlab package registry..."
    curl --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
        --upload-file "$ZIP_NAME" \
        "$GITLAB_DOMAIN/api/v4/projects/$CI_PROJECT_ID/packages/generic/beszel-agent/$CI_COMMIT_TAG/$ZIP_NAME"

    echo "Need to determine the uploaded package's URL..."
    echo "Getting packages for project..."
    PACKAGE_JSON=$(curl --silent --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages")

    PACKAGE_ID=$(echo "$PACKAGE_JSON" | jq -r '.[] | select(.name=="beszel-agent" and .version=="'"$CI_COMMIT_TAG"'") | .id')

    if [ -z "$PACKAGE_ID" ]; then
      echo "‚ùå No matching package found for version $CI_COMMIT_TAG"
      exit 1
    fi

    echo "Found Package ID: $PACKAGE_ID"

    echo "Fetching package files..."
    PACKAGE_FILE_JSON=$(curl --silent --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/$PACKAGE_ID/package_files")

    PACKAGE_FILE_ID=$(echo "$PACKAGE_FILE_JSON" | jq '.[0].id')

    if [ -z "$PACKAGE_FILE_ID" ] || [ "$PACKAGE_FILE_ID" = "null" ]; then
      echo "‚ùå No package files found"
      exit 1
    fi

    PACKAGE_LINK="${GITLAB_DOMAIN}/${CI_PROJECT_PATH}/-/package_files/${PACKAGE_FILE_ID}/download"
    echo "‚úÖ The uploaded package's URL is $PACKAGE_LINK."

    curl --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
      --request POST \
      --header "Content-Type: application/json" \
      --data "{\"name\":\"$ZIP_NAME\",\"url\":\"$PACKAGE_LINK\",\"link_type\":\"package\"}" \
      "$CI_API_V4_URL/projects/$CI_PROJECT_ID/releases/$CI_COMMIT_TAG/assets/links"
    
    echo "AntParade GitOps üêú - create-release job complete."